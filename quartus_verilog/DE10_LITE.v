
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_LITE(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	//input								clk_vga, //TESTING ONLY
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire clk, clk_vga;
assign clk = MAX10_CLK1_50;
wire reset, source_reset, reset_pulse;

wire valid, vsync, hsync, v_en;
wire [9:0] h_addr, v_addr;
wire [11:0] char_frame_addr;
wire [15:0] char_frame;
wire [3:0] glyph_row_addr;
wire [2:0] char_row;
wire [7:0] glyph_row;

wire [7:0] char_code;
wire [3:0] char_fg, char_bg;
assign char_fg = char_frame[15:12];
assign char_bg = char_frame[11:8];
assign char_code = char_frame[7:0];
//0 - 3 | 4 - 7 | 8 - 15
//FG    | BG    | Char


//=======================================================
//  Structural coding
//=======================================================

//Pulse gen so reset button is synchronous
pulse_generator pulsegen(reset_pulse, ~KEY[0], clk);

//VGA clock IP
vga_clock u0 (
		.ref_clk_clk        (clk),        //      ref_clk.clk
		.ref_reset_reset    (reset_pulse),    //    ref_reset.reset
		.vga_clk_clk        (clk_vga),        //      vga_clk.clk
		.reset_source_reset (source_reset)  // reset_source.reset
);

//Generate VGA timing signals
vga_controller vgacontrol(h_addr, v_addr, valid, vsync, hsync, v_en, reset_pulse, clk_vga);

//Generate character timing signals
char_row_counter charrowcounter(glyph_row_addr, char_row, char_frame_addr, v_en, valid, v_addr, clk_vga, reset_pulse);

//RAM containing current character frame
char_ram	char_frame_buffer (
	.clock ( clk ),
	.data ( 16'h0 ),
	.rdaddress ( char_frame_addr ),
	.wraddress ( 12'h0 ),
	.wren ( 1'b0 ),
	.q ( char_frame )
);

/*
reg [3:0] glyph_row_addr_del0, glyph_row_addr_del1, glyph_row_addr_del2, glyph_row_addr_del3, glyph_row_addr_del4, glyph_row_addr_del5, glyph_row_addr_del6, glyph_row_addr_del7, glyph_row_addr_del8, glyph_row_addr_del9, glyph_row_addr_del10, glyph_row_addr_del11, glyph_row_addr_del12, glyph_row_addr_del13, glyph_row_addr_del14, glyph_row_addr_del15;
initial begin
	glyph_row_addr_del0 = 4'b0;
	glyph_row_addr_del1 = 4'b0;
	glyph_row_addr_del2 = 4'b0;
	glyph_row_addr_del3 = 4'b0;
	glyph_row_addr_del4 = 4'b0;
	glyph_row_addr_del5 = 4'b0;
	glyph_row_addr_del6 = 4'b0;
	glyph_row_addr_del7 = 4'b0;
	glyph_row_addr_del8 = 4'b0;
	glyph_row_addr_del9 = 4'b0;
	glyph_row_addr_del10 = 4'b0;
	glyph_row_addr_del11 = 4'b0;
	glyph_row_addr_del12 = 4'b0;
	glyph_row_addr_del13 = 4'b0;
	glyph_row_addr_del14 = 4'b0;
	glyph_row_addr_del15 = 4'b0;
end
always @(posedge clk) begin
	glyph_row_addr_del0 <= glyph_row_addr;
	glyph_row_addr_del1 <= glyph_row_addr_del0;
	glyph_row_addr_del2 <= glyph_row_addr_del1;
	glyph_row_addr_del3 <= glyph_row_addr_del2;
	glyph_row_addr_del4 <= glyph_row_addr_del3;
	glyph_row_addr_del5 <= glyph_row_addr_del4;
	glyph_row_addr_del6 <= glyph_row_addr_del5;
	glyph_row_addr_del7 <= glyph_row_addr_del6;
	glyph_row_addr_del8 <= glyph_row_addr_del7;
	glyph_row_addr_del9 <= glyph_row_addr_del8;
	glyph_row_addr_del10 <= glyph_row_addr_del9;
	glyph_row_addr_del11 <= glyph_row_addr_del10;
	glyph_row_addr_del12 <= glyph_row_addr_del11;
	glyph_row_addr_del13 <= glyph_row_addr_del12;
	glyph_row_addr_del14 <= glyph_row_addr_del13;
	glyph_row_addr_del15 <= glyph_row_addr_del14;
end*/
//wire [3:0] glyph_row_addr_del;
//delay #(1,4) delay1(glyph_row_addr_del, glyph_row_addr, clk);

//ROM containing all 255 glyphs
glyph_rom	glyph_rom_inst (
	.address ( {char_code, glyph_row_addr} ),
	.clock ( clk ),
	.q ( glyph_row )
);
//TODO: Glyph row is an entire row late

//Data comes through char_row_counter -> char_ram -> glyph_rom. By then, it's already old
//Delay through 4 registers to bring it into sync with VGA timing which is delayed below
//reg [2:0] char_row_del0, char_row_del1, char_row_del2, char_row_del3;
reg [2:0] char_row_del [3:0];
initial begin
	char_row_del[0] = 3'b0;
	char_row_del[1] = 3'b0;
	char_row_del[2] = 3'b0;
	char_row_del[3] = 3'b0;
end
always @(posedge clk) begin
	char_row_del[0] <= char_row;
	char_row_del[1] <= char_row_del[0];
	char_row_del[2] <= char_row_del[1];
	char_row_del[3] <= char_row_del[2];
end

//glyph_row contains the current row of the current glyph
//char_row counts from 0 to 7 to go through the row
//pixel contains the current pixel that should be drawn (on or off)
wire pixel;
assign pixel = (char_row_del[3] == 3'h0) ? glyph_row[7] :
					(char_row_del[3] == 3'h1) ? glyph_row[6] :
					(char_row_del[3] == 3'h2) ? glyph_row[5] :
					(char_row_del[3] == 3'h3) ? glyph_row[4] :
					(char_row_del[3] == 3'h4) ? glyph_row[3] :
					(char_row_del[3] == 3'h5) ? glyph_row[2] :
					(char_row_del[3] == 3'h6) ? glyph_row[1] :
					glyph_row[0];

//Filter SW[9:8] through a register so the input is synchronous
//SW[9:8] select what pallette should be used
reg [1:0] pallette_s;
initial begin
	pallette_s = 2'b0;
end
always @(posedge clk) begin
	if (~valid)
		pallette_s <= SW[9:8];
end

//Use a pallette controller to do all the multiplexing for the pallettes
wire [7:0] R, G, B;
pallette_controller(R, G, B, char_fg, char_bg, pallette_s);

//Delay the VGA timing signals through one register each to bring them back into sync
reg [1:0] valid_del, hsync_del, vsync_del;
initial begin
	valid_del = 2'b0;
	hsync_del = 2'b0;
	vsync_del = 2'b0;
end
always @(posedge clk_vga) begin
	valid_del[0] <= valid;
	valid_del[1] <= valid_del[0];
	hsync_del[0] <= hsync;
	hsync_del[1] <= hsync_del[0];
	vsync_del[0] <= vsync;
	vsync_del[1] <= vsync_del[0];
end

//Assign R G and B based off whether we're in the valid region, if a pixel should be drawn, and what color that pixel should be
assign VGA_R = valid_del[1] ? (pixel ? R[7:4] : R[3:0]) : 4'b0;
assign VGA_G = valid_del[1] ? (pixel ? G[7:4] : G[3:0]) : 4'b0;
assign VGA_B = valid_del[1] ? (pixel ? B[7:4] : B[3:0]) : 4'b0;

//Assign HS and VS signals from their delayed versions
assign VGA_HS = hsync_del[1];
assign VGA_VS = vsync_del[1];

endmodule
